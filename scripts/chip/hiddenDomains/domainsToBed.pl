#!/usr/bin/perl

##========================================================================
##
## Author: Joshua Starmer <josh.starmer@gmail.com>, 2014
## 
## Copyright (C) 2014, Joshua Starmer
##
## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License
## as published by the Free Software Foundation; either version 2
## of the License, or (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
## 
##========================================================================

use strict;
use warnings;

use Getopt::Std;

use constant TRUE => 1;
use constant FALSE => 0;

#use constant MIN_DIST => 200;

use constant ID => 0;
use constant CHR => 1;
use constant POS => 2;

my $sHelp = <<END_OF_HELP;

Usage: domainsToBed.pl [options] domainFile.txt > domainFile.bed

NOTE: domainFile.txt should be a file generated by the hiddenDomains R function.

Options

-h
    Print this help information.

-b  BIN_WIDTH
    The width of the bin.  Default is 1000bp.

-g  ChromInfo.txt
    If you get an out of bounds error when uploading a bed file to the UCSC
    genome browser, you can use this option to trim the bounds to the size of 
    the chromosomes.
    ChromInfo.txt should be a tab delimited file with the chromosome names
    in the first column and their sizes in the second column.  Here is an 
    example ChromInfo.txt file for a genome with 3 chromosomes:

    chr1    197195432
    chr2    181748087
    chr3    159599783    

-t
    Create a trackline.

-n  TRACK_NAME
    The name you want to give your track. The default is to use the name of
    the domainFile (without the .txt suffix)

END_OF_HELP

if (-t STDIN && !@ARGV) {
    print STDERR $sHelp;
    exit 1;
}


# process the command line arguments
my %opts; # a hash table to store file names passed in as agruments
getopts('hg:b:n:t', \%opts);

if ($opts{'h'}) { # print help and exit
    print STDERR $sHelp;
    exit 1;
}

my $binWidth = 1000;
if (defined($opts{'b'})) {
    $binWidth = $opts{'b'};
}
print STDERR "binWidth: ".$binWidth." (change with -b option)\n";

my $chrFile = "";
my %chrSizes;
if (defined($opts{'g'})) {
    $chrFile = $opts{'g'};

    print STDERR "Reading in chromosome sizes from: $chrFile\n";

    open(FILE, "<".$chrFile) || die("Could not open $chrFile $!\n");
    while(my $line = <FILE>) {
	chomp($line);
	my ($chr, $size) = split(/\t/, $line);
	$chrSizes{$chr} = $size;
    }
}

my $file = shift(@ARGV);
open(FILE, "<".$file) || die("Could not open $file $!\n");

my $root = $file;
$root =~ s/\.txt//;

my $trackName = $root;
if (defined($opts{'n'})) {
    $trackName = $opts{'n'};
}

if (defined($opts{'t'})) {
    print "track type=bed name=\"".$trackName."\" nextItemButton=on itemRgb=on visibility=dense\n";
}


my $header = <FILE>;
chomp($header);
my @columnNames = split(/\t/, $header);
my $probColumn = 0;
my $found = FALSE;
for(;$probColumn < scalar(@columnNames); $probColumn++) {
    if ($columnNames[$probColumn] eq "enriched.pr") {
	$found = TRUE;
	last;
    }
}
if (!$found) {
    print STDERR "Could not find the column with 'enriched.pr'\n";
    exit;
}


my $counter = 0;
while(my $line = <FILE>) {
    chomp($line);
    my @data = split(/\t/, $line);

    my $chr = $data[CHR];
    my $pos = $data[POS];
    my $endPos = $pos + $binWidth;
    if ($chrFile ne "") {
	if (defined($chrSizes{$chr})) {
	    if ($endPos > $chrSizes{$chr}) {
		print STDERR "trimming ".$chr.":".$endPos." to ".$chrSizes{$chr}."\n";
		$endPos = $chrSizes{$chr};
	    }
	}
    }
    my $postProb = $data[$probColumn];

    my $score = 0;
    my $color = "204,204,204"; 
    if ($postProb >= 0.9) {
	$score = 1000;
	$color = "37,37,37";
} elsif ($postProb >= 0.8) {
	$score = 612;
	$color = "99,99,99";
    } elsif ($postProb >= 0.7) {
	$score = 389;
	$color = "150,150,150";
    } else {
	$score = 167;
	$color = "204,204,204";
    }

    print $chr."\t".$pos."\t".$endPos."\t"."hmm_".$counter."\t".$score."\t.\t".$pos."\t".$endPos."\t".$color."\n";
 
    $counter++;
}
