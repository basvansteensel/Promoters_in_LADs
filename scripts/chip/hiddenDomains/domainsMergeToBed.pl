#!/usr/bin/perl

##========================================================================
##
## Author: Joshua Starmer <josh.starmer@gmail.com>, 2014
## 
## Copyright (C) 2014, Joshua Starmer
##
## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License
## as published by the Free Software Foundation; either version 2
## of the License, or (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
## 
##========================================================================

use strict;
use warnings;

use Getopt::Std;

use constant TRUE => 1;
use constant FALSE => 0;

#use constant MIN_DIST => 200;

use constant ID => 0;
use constant CHR => 1;
use constant POS => 2;
use constant POSTERIOR => 5;

my $sHelp = <<END_OF_HELP;

Usage: domainsMergeToBed.pl [options] domainFile.txt > domainFile.bed

This program merges all consecutive domains with posterior greater than
a threshold (default is 0; all domains are merged) into a single domain.

NOTE: domainFile.txt should be a file generated by the hiddenDomains R function.

Options

-h
    Print this help information.

-b  BIN_WIDTH
    The width of the bin.  Default is 1000bp.

-p  MIN_POSTERIOR
    Toss out parts of domains that have posterior values that are less
    than MIN_POSTERIOR. You can set this to any value you want, but for
    reference, domainsToBed bins according the following scale:
    >= 0.9
    0.9 > posterior >= 0.8
    0.8 > posterior >= 0.7
    0.7 > posterior >= min posterior for significance

    The default value is 0; everything is merged by default.

-g  ChromInfo.txt
    If you get an out of bounds error when uploading a bed file to the UCSC
    genome browser, you can use this option to trim the bounds to the size of 
    the chromosomes.
    ChromInfo.txt should be a tab delimited file with the chromosome names
    in the first column and their sizes in the second column.  Here is an 
    example ChromInfo.txt file for a genome with 3 chromosomes:

    chr1    197195432
    chr2    181748087
    chr3    159599783    

-t
    Create a trackline.

-n  TRACK_NAME
    The name you want to give your track. The default is to use the name of
    the domainFile (without the .txt suffix)

END_OF_HELP

if (-t STDIN && !@ARGV) {
    print STDERR $sHelp;
    exit 1;
}


# process the command line arguments
my %opts; # a hash table to store file names passed in as agruments
getopts('hg:b:p:n:t', \%opts);

if ($opts{'h'}) { # print help and exit
    print STDERR $sHelp;
    exit 1;
}

my $binWidth = 1000;
if (defined($opts{'b'})) {
    $binWidth = $opts{'b'};
}
print STDERR "binWidth: ".$binWidth." (change with -b option)\n";

my $minPost = 0;
if (defined($opts{'p'})) {
    $minPost = $opts{'p'};
}

my $chrFile = "";
my %chrSizes;
if (defined($opts{'g'})) {
    $chrFile = $opts{'g'};

    print STDERR "Reading in chromosome sizes from: $chrFile\n";

    open(FILE, "<".$chrFile) || die("Could not open $chrFile $!\n");
    while(my $line = <FILE>) {
	chomp($line);
	my ($chr, $size) = split(/\t/, $line);
	$chrSizes{$chr} = $size;
    }
}

my $file = shift(@ARGV);
open(FILE, "<".$file) || die("Could not open $file $!\n");

my $root = $file;
$root =~ s/\.txt//;

my $trackName = $root;
if (defined($opts{'n'})) {
    $trackName = $opts{'n'};
}

if (defined($opts{'t'})) {
    print "track type=bed name=\"".$trackName."\" nextItemButton=on itemRgb=on visibility=dense\n";
}

my $header = <FILE>;
chomp($header);
my @columnNames = split(/\t/, $header);
my $probColumn = 0;
my $found = FALSE;
for(;$probColumn < scalar(@columnNames); $probColumn++) {
    if ($columnNames[$probColumn] eq "enriched.pr") {
	$found = TRUE;
	last;
    }
}
if (!$found) {
    print STDERR "Could not find the column with 'enriched.pr'\n";
    exit;
}


my $counter = 0;
my $prevLine = <FILE>;
my @prevData = split(/\t/, $prevLine);
my $prevChr = $prevData[CHR];
my $prevPos = $prevData[POS];
my $prevEnd = $prevPos + $binWidth;
my $leftPos = $prevPos;
while(my $line = <FILE>) {
    chomp($line);
    my @data = split(/\t/, $line);

    if ($data[POSTERIOR] < $minPost) {
	next;
    }

    my $chr = $data[CHR];
    my $pos = $data[POS];
    my $endPos = $pos + $binWidth;
    my $chrSize;
    if ($chrFile ne "") {
	if (defined($chrSizes{$chr})) {
	    $chrSize = $chrSizes{$chr};
	    if ($endPos > $chrSize) {
		print STDERR "trimming ".$chr.":".$endPos." to ".$chrSize."\n";
		$endPos = $chrSize;
	    }
	}
    }

    if ($chr eq $prevChr) {
	if ($prevEnd == $pos) {
	    $prevPos = $pos;
	    $prevEnd = $pos + $binWidth;
	    next;
	} else {
	    if ($chrFile ne "") {
		if ($prevEnd > $chrSize) {
		    print STDERR "trimming ".$chr.":".$prevEnd." to ".$chrSize."\n";
		    $prevEnd = $chrSize;
		}
	    }

	    print $prevChr."\t".$leftPos."\t".$prevEnd."\t"."hmm_".$counter."\n";
	    $counter++;

	    $prevPos = $pos;
	    $leftPos = $pos;
	    $prevEnd = $pos + $binWidth;
	    next;
	}
    } else {
	if ($chrFile ne "") {
	    if (defined($chrSizes{$prevChr})) {
		$chrSize = $chrSizes{$prevChr};
		if ($prevEnd > $chrSize) {
		    print STDERR "trimming ".$prevChr.":".$prevEnd." to ".$chrSize."\n";
		    $prevEnd = $chrSize;
		}
	    }
	}

	print $prevChr."\t".$leftPos."\t".$prevEnd."\t"."hmm_".$counter."\n";
	$counter++;

	$prevChr = $chr;
	$prevPos = $pos;
	$leftPos = $pos;
	$prevEnd = $pos + $binWidth;
	next;
    }
    $counter++;

}

my $chrSize;
if ($chrFile ne "") {
    if (defined($chrSizes{$prevChr})) {
	$chrSize = $chrSizes{$prevChr};
	if ($prevEnd > $chrSize) {
	    print STDERR "trimming ".$prevChr.":".$prevEnd." to ".$chrSize."\n";
	    $prevEnd = $chrSize;
	}
    }
}

print $prevChr."\t".$leftPos."\t".$prevEnd."\t"."hmm_".$counter."\n";
